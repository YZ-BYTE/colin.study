## 算法积累



​                                    <img src="C:\Users\zhanr\AppData\Roaming\Typora\typora-user-images\image-20250916081940632.png" alt="image-20250916081940632" style="zoom:50%;" />     

### 双指针：283.移动零

定义两个指针left和right，初始指向数组开头，right负责遍历数组遇非零值与left交换。

<img src="C:\Users\zhanr\AppData\Roaming\Typora\typora-user-images\image-20250916082302438.png" alt="image-20250916082302438" style="zoom:50%;" />

----------------------------------------------------------------------------------------------------------------------------------------------------

-

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250916093317859.png" alt="image-20250916093317859" style="zoom:50%;" />

### 链表：206.反转链表



1. 使用三个指针：prev（前一个节点）、curr（当前节点）和 nextTemp（下一个节点的临时保存）

2. 遍历链表时，将当前节点的 next 指针指向 prev，实现反转

3. 移动 prev 和 curr 指针，继续处理下一个节点

4. 当 curr 为 nullptr 时，prev 就是反转后链表的头节点

5. <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250916093515974.png" alt="image-20250916093515974" style="zoom:50%;" />

   ----------------------------------------------------------------------------------------------------------------------------------------------------

   

   <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250917151309273.png" alt="image-20250917151309273" style="zoom:50%;" />

   ### 双指针：11.盛最多水的容器

   解题思路是使用左右两个指针，分别从数组的两端开始移动：

   1. 计算当前两个指针所指垂线形成的容器的水量
   2. 比较并更新最大水量
   3. 移动高度较小的那个指针（因为移动高度较大的指针只会导致水量减少或不变）
   4. 重复上述步骤直到两个指针相遇
   5. 

   

   -------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250918110404392.png" alt="image-20250918110404392" style="zoom:50%;" />

### 双指针：15.三数之和

​	1.先对数组进行排序，便于后续去重和使用双指针
​	2.固定第一个元素，然后使用双指针寻找两个元素
​	3.通过跳过相同元素确保三元组不重复
​	去重操作通过跳过相同元素实现：
​			对第一个元素：如果与前一个相同则跳过
​			对找到的有效三元组，左右指针都要跳过相同元素
当第一个元素大于0时，三数之和必然大于0，可以提前返回结果		

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250918111023257.png" alt="image-20250918111023257" style="zoom:50%;" />

---------------------------------------------------------------------------------------------------------------------------------------------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250919202641691.png" alt="image-20250919202641691" style="zoom:50%;" />

### 二叉树：102.二叉树的层序遍历

队列：保存待处理的节点
根节点入队
遍历：打印对首元素，将队首元素的非空孩子放入队列等待处理

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250919202948637.png" alt="image-20250919202948637" style="zoom:50%;" />



------------------------------------------------------------------------------------------------------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250920164636100.png" alt="image-20250920164636100" style="zoom:50%;" />

### 博弈，动态规划：375.猜数字大小2

​	通过区间DP来解决：
​		对于每个区间[i,j],最优策略是选择一个k作为猜测值
​		花费为k加上左右两个子区间的最大花费
​		从所有可能的k中选择花费最小的那个

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250920165434985.png" alt="image-20250920165434985" style="zoom:50%;" />

------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250921222126851.png" alt="image-20250921222126851" style="zoom:50%;" />

### 回溯法：17.电话号码的字母组合

回溯三部曲：1.递归函数的返回值以及参数 2.回溯终止条件 3.单层搜索的过程

1. 用数组存储数字到字母的映射关系
2. 若输入为空直接返回空结果
3. 递归回溯生成组合：
   - 从第一个数字开始，取对应字母
   - 逐个尝试当前数字的所有字母，添加到临时组合
   - 递归处理下一个数字，直到所有数字都处理完则保存组合
   - 回溯时移除最后添加的字母，继续尝试其他可能

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250921222444294.png" alt="image-20250921222444294" style="zoom:50%;" />

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250925224401972.png" alt="image-20250925224401972" style="zoom:50%;" />

### 动态规划：62.不同路径

​	dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的径。
​	想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和dp[i][j - 1]。
​	这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250925224604350.png" alt="image-20250925224604350" style="zoom:50%;" />

-------------------------------------------------------------------------------------------------------------------------------------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250926155239793.png" alt="image-20250926155239793" style="zoom:50%;" />

### 树形动态规划：2246.相邻字符不同的最长路径

​	状态定义：函数height的返回值：以root为起点，向下延伸的最长有效路径长度
​	状态转移：若左子节点与当前节点字符不同，则左子树的有效贡献为 `left_h`；否则为 0
​					  同理计算右子树的有效贡献 `right_valid`。
​					  当前节点的状态=max(left_valid,right_valid)+1;
​	全局最优解：通过max_len记录全局最长路径

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250926155424925.png" alt="image-20250926155424925" style="zoom:50%;" />

--------------------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250928223012044.png" alt="image-20250928223012044" style="zoom:50%;" />

### 动态规划：63.不同路径2

​			本题是[62.不同路径 (opens new window)](https://programmercarl.com/0062.不同路径.html)的障碍版，整体思路大体一致。但就算是做过62.不同路径，在做本题也会有感觉遇到障碍无从下手。其实只要考虑到，遇到障碍dp[i][j]保持0就可以了。也有一些小细节，例如：初始化的部分，很容易忽略了障碍之后应该都是0的情况。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250928223203486.png" alt="image-20250928223203486" style="zoom:50%;" />

-------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250929160534137.png" alt="image-20250929160534137" style="zoom:50%;" />

### 动态规划：343.整数拆分

1.确定dp数组及其下标含义：dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
2.确定递推公式：dp[i]=max(dp[i],max(j*(i-j),j*dp[i-j]));
3.初始化：dp[2] = 1
4.遍历顺序：dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250929161308769.png" alt="image-20250929161308769" style="zoom:50%;" />

-------------------------

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251001000346418.png" alt="image-20251001000346418" style="zoom:50%;" />

### 动态规划：516.最长回文子序列

1. **定义 dp 数组及下标含义**设`dp[i][j]`表示字符串`s`在区间`[i, j]`（从索引`i`到`j`）内的最长回文子序列长度。

2. **确定递推公式**

   - 若`s[i] == s[j]`，则`dp[i][j] = dp[i+1][j-1] + 2`（两端字符相同，长度加 2）。
   - 若`s[i] != s[j]`，则`dp[i][j] = max(dp[i+1][j], dp[i][j-1])`（取去掉左端或右端字符后的后的最大值）。

3. **初始化 dp 数组**

   - 单个字符的回文子序列长度为 1，故`dp[i][i] = 1`（i和j相同情况回文子序列为1）。
   - 其余位置初始化为 0，避免干扰递推计算。

4. **确定遍历顺序**

   - `i`从字符串尾到上遍历（`s.size()-1` → 0），确保计算`dp[i][j]`时，`dp[i+1][...]`已就绪。

   - `j`从`i+1`开始向右遍历，保证`j > i`（子串长度≥2）。
     <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251001000657477.png" alt="image-20251001000657477" style="zoom:50%;" />

     ---------------

     

     <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251002113150384.png" alt="image-20251002113150384" style="zoom:50%;" />

     ### 动态规划 区间DP：1039.多边形三角刨分的最低得分

     

     1.DP数组的含义：定义 `dp[i][j]` 表示由顶点 `i` 到顶点 `j`（包含 `i` 和 `j`）构成的凸多边形进行三角剖分后可能得到的最低分数。
     2.状态转移方程为：`dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + values[i] * values[j] * values[k])`

     3.DP数组初始化：设为最大值INT_MAX

     4.遍历顺序：按照多边形的长度从小到大计算，先计算长度为 3 的三角形，再逐步计算更长的多边形。
     <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251002113548653.png" alt="image-20251002113548653" style="zoom:50%;" />

     ------------

     ### 贪心算法：455.分发饼干

     <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251006211830255.png" alt="image-20251006211830255" style="zoom:50%;" />

     - 将问题分解为若干个子问题
     - 找出适合的贪心策略
     - 求解每一个子问题的最优解
     - 将局部最优解堆叠成全局最优解

     **这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。
     <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251006212152690.png" alt="image-20251006212152690" style="zoom:50%;" />

     -------

   ### 单调栈：739.每日温度

   <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251008231321883.png" alt="image-20251008231321883" style="zoom:50%;" />

   什么时候用单调栈呢？

   **通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。
   单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

   - 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
   - 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
   - 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况

   <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251008234001110.png" alt="image-20251008234001110" style="zoom:50%;" />

   -----------

   ### 双端队列：239.滑动窗口的最大值

   <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251010131335170.png" alt="image-20251010131335170" style="zoom:50%;" />

   <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251010131406198.png" alt="image-20251010131406198" style="zoom:50%;" />

   ---------

   ### 优先队列（最小堆）：347.前k个高频元素

   <img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251010140209702.png" alt="image-20251010140209702" style="zoom:50%;" />

   为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

   1. 首先统计每个元素的出现频率
   2. 使用最小堆来维护出现频率最高的 k 个元素
   3. 当堆的大小超过 k 时，移除频率最小的元素
   4. 最后从堆中提取结果并返回

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251010140352710.png" alt="image-20251010140352710" style="zoom:50%;" />

-------

### 回溯算法：40组合数去重II

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251013180311729.png" alt="image-20251013180311729" style="zoom:50%;" />

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251013184634795.png" alt="image-20251013184634795" style="zoom:50%;" />

----------

### 动态规划：101分割等和子集（01背包）

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251015121527220.png" alt="image-20251015121527220" style="zoom:50%;" />

问题转化原问题等价于：能否从数组中选若干元素，使其和等于target = 总和/2（总和必须为偶数，否则直接返回 false）。
dp 数组定义
dp[j]：容量为j的背包，能装入的元素最大和（元素的 “重量” 与 “价值” 均为自身数值）。
若dp[target] == target，说明能装满容量target的背包，即存在符合条件的子集。
关键递推与初始化
递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])，决策 “选当前元素” 或 “不选”，取最大和。
初始化：dp[0] = 0（容量 0 的背包和为 0），其余dp[j] = 0（元素均为正整数，初始 0 不影响后续取最大值）。
遍历顺序
外层遍历每个元素（每个 “物品” 只能用一次）。
内层从target倒序遍历到nums[i]，避免同一元素被重复使用，保证 01 背包特性。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251015121809445.png" alt="image-20251015121809445" style="zoom:50%;" />

---------------

### 贪心算法：376摆动序列

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251016155126114.png" alt="image-20251016155126114" style="zoom:50%;" />

计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果`prediff < 0 && curdiff > 0` 或者 `prediff > 0 && curdiff < 0` 此时就有波动就需要统计。
	考虑三种情况：

1. 情况一：上下坡中有平坡
2. 情况二：数组首尾两端
3. 情况三：单调坡中有平坡

我们应该什么时候更新 prediff 呢？
	我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251016155824668.png" alt="image-20251016155824668" style="zoom:50%;" />



#### 动态规划：

- 设 dp 状态`dp[i][0]`，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度
- 设 dp 状态`dp[i][1]`，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度

则转移方程为：

- `dp[i][0] = max(dp[i][0], dp[j][1] + 1)`，其中`0 < j < i`且`nums[j] < nums[i]`，表示将 nums[i]接到前面某个山谷后面，作为山峰。
- `dp[i][1] = max(dp[i][1], dp[j][0] + 1)`，其中`0 < j < i`且`nums[j] > nums[i]`，表示将 nums[i]接到前面某个山峰后面，作为山谷。

初始状态：

由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：`dp[0][0] = dp[0][1] = 1`。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251016162138113.png" alt="image-20251016162138113" style="zoom:50%;" />

----------

### 链表：142.环形链表II

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251017214212413.png" alt="image-20251017214212413" style="zoom:50%;" />

​		使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环
​		<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251017214311761.png" alt="image-20251017214311761" style="zoom:50%;" />

(x + y) * 2 = x + y + n (y + z)
两边消掉一个（x+y）: `x + y = n (y + z)`
因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。`x = n (y + z) - y` 
再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z` 
意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251017214458362.png" alt="image-20251017214458362" style="zoom:50%;" />

-------------

### 链表：25.k个一组翻转链表

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251018235015877.png" alt="image-20251018235015877" style="zoom:50%;" /><img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251018235104577.png" alt="image-20251018235104577" style="zoom: 67%;" />

-------------

### 贪心算法：45跳跃游戏II

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251020221546868.png" alt="image-20251020221546868" style="zoom:50%;" />

局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时

- 如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。
- 如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251020221714274.png" alt="image-20251020221714274" style="zoom:50%;" />

--------------

### 贪心算法：135.分发糖果

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251022210649753.png" alt="image-20251022210649753" style="zoom:50%;" />

这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，**如果两边一起考虑一定会顾此失彼**。先确定右边评分大于左边的情况（也就是从前向后遍历）此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果局部最优可以推出全局最优。再确定左孩子大于右孩子的情况（从后向前遍历）遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？因为 rating[5]与rating[4]的比较 要利用上 rating[5]与rating[6]的比较结果，所以 要从后向前遍历。如果从前向后遍历，rating[5]与rating[4]的比较 就不能用上 rating[5]与rating[6]的比较结果了 。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251022210828838.png" alt="image-20251022210828838" style="zoom:50%;" />

------------------

### 动态规划：188.买卖股票的最佳时机IV

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251023101839526.png" alt="image-20251023101839526" style="zoom:50%;" />

**除了0以外，偶数就是卖出，奇数就是买入**。

题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。所以二维dp数组的C++定义为：

```cpp
vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
```

1. 确定递推公式

还要强调一下：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区。达到dp[i][1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]

选最大的，所以 dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);同理dp[i][2]也有两个操作：

- 操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]

所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251023102051334.png" alt="image-20251023102051334" style="zoom:50%;" />、

-----------------------

### 贪心算法：435.无重叠区间

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251025214753837.png" alt="image-20251025214753837" style="zoom:50%;" />

​		先按区间起始位置排序，初始化首个区间结束值为初始 end，遍历后续区间时，若当前区间起始不小于 end 则更新 end 为当前区间结束（无重叠），否则取两区间结束值较小者更新 end 并计数（需移除重叠区间），最终返回计数即需移除的最少区间数。
每一步处理当前区间时，选择**保留结束位置更早的区间**（即 `end = min(end, intervals[i][1])`），这个局部最优选择能最大限度减少对后续区间的干扰（给后续区间留出更多空间）。

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251025215023512.png" alt="image-20251025215023512" style="zoom:50%;" />

-------------------

### 动态规划：494.目标和（背包问题）

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251028151625138.png" alt="image-20251028151625138" style="zoom:50%;" />

##### 二维数组方法：

确定dp数组以及下标的含义

先用 二维 dp数组求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。
01背包为什么这么定义dp数组，我在[0-1背包理论基础 (opens new window)](https://www.programmercarl.com/背包理论基础01背包-1.html)中 确定dp数组的含义里讲解过。

确定递推公式

**不放物品i**：即背包容量为j，里面不放物品i，装满有dp[i - 1][j]中方法。
**放物品i**： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp[i - 1][j - 物品i容量] 种方法。
本题中，物品i的容量是nums[i]，价值也是nums[i]。
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251028152236946.png" alt="image-20251028152236946" style="zoom:33%;" />

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0; // 此时没有方案
        if ((target + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (target + sum) / 2;
        
        vector<vector<int>> dp(nums.size(), vector<int>(bagSize + 1, 0));
        
        // 初始化最上行
        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; 

        // 初始化最左列，最左列其他数值在递推公式中就完成了赋值
        dp[0][0] = 1; 

        int numZero = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) numZero++;
            dp[i][0] = (int) pow(2.0, numZero);
        }

        // 以下遍历顺序行列可以颠倒
        for (int i = 1; i < nums.size(); i++) { // 行，遍历物品
            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包
                if (nums[i] > j) dp[i][j] = dp[i - 1][j]; 
                else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
            }
        }
        return dp[nums.size() - 1][bagSize];
    }
};
```

##### 一维数组

##### 二维DP数组递推公式： `dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];`

去掉维度i 之后，递推公式：`dp[j] = dp[j] + dp[j - nums[i]]` ，即：`dp[j] += dp[j - nums[i]]`

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251028152808465.png" alt="image-20251028152808465" style="zoom:50%;" />

------------------

### 回溯法：51.N皇后

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251029231849357.png" alt="image-20251029231849357" style="zoom:50%;" />

按照如下标准去重：不能同行，不能同列，不能同斜线 （45度和135度角）
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251029231955865.png" alt="image-20251029231955865" style="zoom:33%;" /><img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251029232056177.png" alt="image-20251029232056177" style="zoom:25%;" />

```cpp
class Solution {
public:
    
    vector<vector<string>>res;
    void backtracking(int n,int hang,vector<string>FF){
        if(n==hang){
            res.push_back(FF);
            return;
        }
        for(int lie=0;lie<n;lie++){
            if(isture(hang,lie,FF,n)){
                FF[hang][lie]='Q';
                backtracking(n,hang+1,FF);
                FF[hang][lie]='.';
            }
        }
    }
    bool isture(int hang,int lie,vector<string>FF,int n){
        //正上方   是否有皇后
        for(int i=0;i<hang;i++){
            if(FF[i][lie]=='Q')return false;
        }
        //斜左上方 是否有皇后
        for(int i=hang-1,j=lie-1;i>=0&&j>=0;i--,j--){
            if(FF[i][j]=='Q')return false;
        }
        //斜右上方 是否有皇后
        for(int i=hang-1,j=lie+1;i>=0&&j<=n;i--,j++){
            if(FF[i][j]=='Q')return false;
        }
        return true;
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string>FF(n,string(n,'.'));
         backtracking(n, 0, FF);
         return res;
    }
};
```

-----------------

### 二叉树：106.从中序遍历和后序遍历中构建二叉树

每次后序遍历的最后一个节点为树的根节点，创建哈希表存中序遍历，在中序遍历中找到这个值，值的左边为树的左子树，右边为右子树

```cpp
class Solution {
public:
    int post;
    unordered_map<int,int>inorder_map;
    TreeNode* create(int left,int right,vector<int>& inorder, vector<int>& postorder){
        if(left>right)return nullptr;
        int rootval=postorder[post];
        TreeNode*root =new TreeNode(rootval);
        //根据root所在位置分成左右两颗子树
        int index=inorder_map[rootval];
        post--;
        //构建右子树
        root->right=create(index+1,right,inorder,postorder);
        //构建左子树
        root->left=create(left,index-1,inorder,postorder);
        return root;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        //递归构建二叉树时，快速找到根节点在中序数组中的位置。
        int index=0;
        for(auto& val: inorder){
            inorder_map[val]=index++;
        }
        //从后序遍历的最后一个元素开始，为根节点
        post=postorder.size()-1;
        //递归构建二叉树
        return create(0,inorder.size()-1,inorder,postorder);
    }
};
```

### 贪心算法：406.根据身高重建队列

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251102165044833.png" alt="image-20251102165044833" style="zoom:50%;" />

遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。
**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**
**全局最优：最后都做完插入操作，整个队列满足题目队列属性**

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251102172153531.png" alt="image-20251102172153531" style="zoom:50%;" />

---------------

### 链表：148.排序链表（用归并排序）

找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。
对两个子链表分别排序。
将两个排序后的子链表合并，得到完整的排序后的链表。

```cpp
//使用归并排序
class Solution {
public:
//合并
    ListNode* merge(ListNode*head1,ListNode*head2){
        //创建虚拟头结点
        ListNode*xuhead=new ListNode(0);
        ListNode*t=xuhead,*t1=head1,*t2=head2;
        while(t1!=nullptr&&t2!=nullptr){
            if(t1->val<=t2->val){
                t->next=t1;
                t1=t1->next;
            }else{
                t->next=t2;
                t2=t2->next;
            }
            t=t->next;
        }
        if(t1!=nullptr)t->next=t1;
        if(t2!=nullptr)t->next=t2;
        return xuhead->next;
    }
//排序
    ListNode* sortList(ListNode* head) {
        if(head==nullptr||head->next==nullptr){
            return head;
        }
        ListNode*slow=head;//利用快慢指针找到链表中点
        ListNode*fast=head;
        while(fast!=nullptr && fast->next != nullptr){
            slow=slow->next;
            fast=fast->next->next;
        }
        ListNode* mid=slow;
        //将链表切分成两部分
        ListNode*t=head;
        while(t->next!=mid)t=t->next;
        t->next=nullptr;//断开前半部分
        return merge(sortList(head),sortList(mid));
    }
};
```

--------------

链表：递归合并两个有序链表

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == nullptr) {
            return l2;
        } else if (l2 == nullptr) {
            return l1;
        } else if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
```

-----------------

### 整数反转：7整数反转

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251106141423588.png" alt="image-20251106141423588" style="zoom:50%;" />

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251106141435325.png" alt="image-20251106141435325" style="zoom:50%;" />

--------------

### 图论：200.岛屿数量

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251108225511912.png" alt="image-20251108225511912" style="zoom:50%;" />

我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。

最终岛屿的数量就是我们进行深度优先搜索的次数。<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251108225539682.png" alt="image-20251108225539682" style="zoom:50%;" />

-------------------------

### 链表：2.两数之和

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251111224024242.png" alt="image-20251111224024242" style="zoom:50%;" />

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251111224052106.png" alt="image-20251111224052106" style="zoom:50%;" />

-------------------

### 单调栈：496.下一个更大元素1

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251112124219976.png" alt="image-20251112124219976" style="zoom:50%;" />

用哈希表映射nums1元素与下标，单调栈（存nums2下标，维持递减）遍历nums2：遇小元素压栈，遇大元素弹出栈顶，若栈顶元素在nums1中则通过哈希表更新对应结果，最终返回默认值为-1的结果数组。
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251112124328663.png" alt="image-20251112124328663" style="zoom:50%;" />

-------

### 二叉树：101.对称二叉树

```cpp
class Solution {
public:
    bool duichen(TreeNode* pl, TreeNode* pr) {
        if (pl == nullptr && pr == nullptr)
            return true;
        if (pl != nullptr && pr == nullptr || pl == nullptr && pr != nullptr)
            return false;
        if (pl->val != pr->val)
            return false;
        return duichen(pl->left, pr->right) && duichen(pl->right, pr->left);
    }

    bool isSymmetric(TreeNode* root) {
        if (root == nullptr)
            return false;
        return duichen(root, root);
    }
};

```

----------

### 矩阵：54.螺旋矩阵

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251114221215574.png" alt="image-20251114221215574" style="zoom:50%;" />

首先设定上下左右边界
其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界
判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案
若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理
不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251114221247157.png" alt="image-20251114221247157" style="zoom:50%;" />

------------

### 数组：238.除自身以外数组的乘积

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251115185037289.png" alt="image-20251115185037289" style="zoom:50%;" />

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251115185105362.png" alt="image-20251115185105362" style="zoom:50%;" />

------------

### 滑动窗口：[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251117192015224.png" alt="image-20251117192015224" style="zoom:50%;" />

------------

### 迭代法中序遍历：<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251118094649205.png" alt="image-20251118094649205" style="zoom:50%;" />

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
       stack<TreeNode*>order_stack;
       while(root!=nullptr||order_stack.size()>0){
        while(root!=nullptr){
            order_stack.push(root);
            root=root->left;
        }
        root=order_stack.top();
        order_stack.pop();
        k--;
        if(k==0){
            break;
        }
        root=root->right;
       }
       return root->val;
    }
};
```

-----------

### 哈希表+双向链表：[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119221334534.png" alt="image-20251119221334534" style="zoom:50%;" />

​	用双向链表按「最近使用顺序」维护节点（头部为最近使用、尾部为最久未使用），用哈希表映射键与链表节点以实现O(1)定位；get操作时，若键存在则通过哈希表找到节点并移至链表头部（更新最近使用状态），否则返回-1；put操作时，若键不存在则新建节点插入表头并添加到哈希表，若超出容量则删除链表尾部（最久未使用）节点并从哈希表移除，若键已存在则更新节点值并移至表头，确保缓存始终保留最近使用的数据且操作高效。

```cpp
// 双向链表节点结构体： 存储键值对+前后指针
struct DLinkedNode {
    int key;
    int value;
    DLinkedNode* prev;
    DLinkedNode* next;
    // 无参构造，用于创建虚拟头，尾节点
    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}
    // 有参构造，用于创建实际缓存节点
    DLinkedNode(int key, int value)
        : key(key), value(value), prev(nullptr), next(nullptr) {}
};
// LRU缓存类：哈希表+双向链表
class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head; // 伪头部节点
    DLinkedNode* tail; // 伪尾部节点
    int size;          // 当前缓存中已存储的节点数量
    int capacity;      // 缓存的最大容量
public:
    // 初始化缓存
    LRUCache(int capacity) : capacity(capacity), size(0) {
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    // 获取key对应的value
    int get(int key) {
        if (!cache.count(key))
            return -1;
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }

    void put(int key, int value) {
        if (!cache.count(key)) {
            DLinkedNode* node = new DLinkedNode(key, value);
            cache[key] = node;
            addToHead(node);
            ++size;
        }
        if (size > capacity) {
            DLinkedNode* removed = removeTail();
            cache.erase(removed->key);
            delete removed;
            --size;
        } else {
            // 2.1 通过哈希表定位到已存在的节点
            DLinkedNode* node = cache[key];
            // 2.2 更新节点的 value（覆盖旧值）
            node->value = value;
            // 2.3 将节点移到链表头部（标记为「最近使用」）
            moveToHead(node);
        }
    }


    //双向链表插入需修改4个指针，顺序不能错
    void addToHead(DLinkedNode* node){
        node->prev=head;
        node->next=head->next;
        head->next->prev=node;
        head->next=node;
    }
    void removeNode(DLinkedNode* node){
        node->prev->next=node->next;
        node->next->prev=node->prev;
    }
    void moveToHead(DLinkedNode* node){
        removeNode(node);
        addToHead(node);
    }
    DLinkedNode* removeTail(){
        DLinkedNode*node=tail->prev;
        removeNode(node);
        return node;
    }
};
```

















































































































































