### 用双向链表实现贪吃蛇

#### 1.核心数据结构：双向链表

​	贪吃蛇的身体由多个节点组成，使用双向链表存储是最佳选择，因为蛇的移动的本质是头部新增节点+尾部删除节点。
​	每个节点存储：当前节点的坐标，前驱指针，后继指针
​	全局变量snakeHead和snakeTail分别指向链表的头和尾

```C++
typedef struct SnakeNode{
    int lie;//列坐标
    int hang;//行坐标
    struct SnakeNode* prev;//前驱节点指向尾部方向
    struct SnakeNode* next;//后继节点指向头部方向
}SnakeNode,*SnakeList;
```

#### 2.链表操作

##### 创建节点createNode

​	功能：为新蛇节分配内存并初始化坐标

```c++
SnakeNode* createNode(int lie,int hang){
    SnakeNode* node=(SnakeNode*)malloc(sizeof(SnakeNode));
    node->lie=lie;
    node->hang=hang;
    node->prev=NULL;
    node->next=NULL;
    return node;
}
```

#####  初始化蛇链表initSnakeList

​	功能：创建初始长度为5的蛇，头部在（10,10），尾部在（10,14）
​	从尾部向头部创建节点，通过newNode->next=snakeHead将新节点插入头部	

```C++
void initSnakeList(){
    //先释放原有链表，防止内存泄漏
    if(snakeHead!=NULL)freeSnakeList();
    //创建初始5节蛇身，列固定为10，行从10到14
    for(int i=4;i>=0;i--){
        SnakeNode* newNode=createNode(10,10+i);
        if(snakeHead==NULL){
            //第一个节点
            snakeHead=newNode;
            snakeTail=newNode;
        }else{
            //后续节点插入头部前面
            newNode->next=snakeHead;
            snakeHead->prev=newNode;
            snakeHead=newNode;
        }
    }
}
```

##### 头部插入节点addHead

功能：在蛇头前新增一节（蛇移动时调用，模拟向前走）

```C++
void addHead(int lie,int hang){
    SnakeNode* newNode=createNode(lie,hang);
	newNode->next=snakeHead;//新节点的后继指向原头部
    snakeHead->prev=newNode;//原头部的前驱指向新节点
    snakeHead=newNode;//更新头部为新节点
}
```

##### 删除尾部节点removeTail

功能：删除蛇尾最后一节（蛇移动且没迟到苹果时调用，保持长度不变)
注意：必须释放内存，否则会造成内存泄漏

```C++
void removeTail(){
    SnakeNode* temp=snakeTail;
    snakeTail=snakeTail->prev;//尾部前移
    snakeTail->next=NULL;//新尾部的后继置空
    free(temp);//释放原尾部内存
}
```

##### 释放链表freeSnakeList

功能：游戏结束时释放所有节点内存，避免内存泄漏

```C++
void freeSnakeList(){
    SnakeNode* current=snakeHead;
    while(current!=NULL){
        SnakeNode* temp=current;
        current=current->next;
        free(temp);
    }
    snakeHead=NULL;
    snakeHead=NULL;
}
```

#### 3.游戏核心逻辑解析

##### 游戏初始化initgame与gameInit

​	initgame：初始化随机数，背景色，调用initSnakeList创建蛇
​	gameInit:加载图片资源（背景，苹果，蛇头，蛇身），生成初始苹果位置

##### 蛇的移动逻辑

​	蛇的移动不是每个节点平移，而是头部新增+尾部删除，类似队列的FIFO特性
​	吃苹果逻辑：吃到苹果时只加头部不删尾部，蛇自然变长

```C++
//获取当前蛇头坐标
int headLie=snakeHead->lie;
int headHang=snakeHead->hang;
//按方向计算新头部坐标
switch (fx) {
	case 0: headLie++; break;  // 右移
	case 1: headHang--; break; // 上移
	case 2: headLie--; break;  // 左移
	case 3: headHang++; break; // 下移
}
//头部新增节点（向前移动一步）
addHead(headLie,headHang);
//判断是否吃苹果：吃了则不删尾部重新生成苹果坐标，否则删除尾部
if(headHang==appleHang&&headLie==appleLie){
    //重新生成苹果
    appleLie=rand()%14+3;
    appleHang=rand()%14+3;
}else{
    removeTail();
}
```

##### 碰撞检测：

判断蛇头坐标是否超出窗口边界（headHang<=0或>=19等）
自身碰撞检测：遍历蛇身所有节点，判断蛇头是否与任何一节身体坐标重合

```C++
bool checkSelfCollision(){
    SnakeNode*current=snakeHead->next;//从头部的下一节开始检查
    while(current!=NULL){
        if(snakeHead->lie==current->lie&&snakeHead->hang==current->hang){
            return true;//蛇头与身体某节坐标重合
        }
        current=current->next;
    }
    return false;
}
```

##### 绘图逻辑

绘制背景和苹果
绘制蛇头：`putimage(snakeHead->lie * 30, snakeHead->hang * 30, &imgHead[fx])`
绘制蛇身：遍历链表从`snakeHead->next`到`snakeTail`，逐个绘制每个节点

##### 键盘控制

通过方向键改变移动方向（`fx`变量）
防止反向移动：例如当前向右（`fx=0`）时，不能直接向左（`fx=2`）









