## 数据结构

### 红黑树

#### 红黑树的删除

​	**1.被删除节点为根且没有孩子**
​			删除Z，将树赋空。
​	**2.被删除节点为根且有一个孩子**
​			红子->黑，孩子变为根，删除Z。

​	**3.被删除节点是红色节点**
​			直接删除Z。
​	**4.被删除节点是非根黑色节点，有一个孩子**
​			子节点变黑与爷节点相连，删除Z。
​	**5.被删除节点是非根黑色节点，没有孩子**
​			**1.兄弟是红节点**
​					兄父变色，以父节点为旋转点朝Z旋转，继续讨论。
​			**2.兄弟是黑节点**
​				a.兄弟有一个孩子是**红**节点
​					兄弟在父亲的左侧，红侄子在兄弟的左侧：红侄子变黑，兄色变父色，父色变黑，以父为旋转点右旋
​					兄弟在父亲的右侧，红侄子在兄弟的右侧：红侄子变黑，兄色变父色，父色变黑，以父为旋转点左旋
​					兄弟在父亲的左侧，红侄子在兄弟的右侧：红侄子变父色，父色变黑，以兄弟为旋转点左旋，以父为旋转点右旋
​					兄弟在父亲的右侧，红侄子在兄弟的左侧：红侄子变父色，父色变黑，以兄弟为旋转点右旋，以父为旋转点左旋	
​				b.兄弟的孩子都是**黑**色
​					兄弟变红，父为新Z继续讨论	

----------------------

#### 红黑树的插入

空树：插入黑色节点
非空树：父亲是黑色，插入红色节点

![image-20250929150830997](C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20250929150830997.png)

---------



###哈希表

#### 什么是哈希冲突？

不同的 Key 经哈希函数计算后，得到相同的哈希表索引，导致多个 Value 需存入同一位置，这就是哈希冲突。

---------



### B树和B+树

-----------



### 最大流

​		**简单算法求阻塞流**：1.  找从起点到终点的简单路径 2.找瓶颈值（找这条路线上的最小值） 3.更新残量图    重复以上三步直到没有简单路径得阻塞流
​		最大流算法：
​			**Ford-Fulkerson算法**：1.选择一条简单路径 2.瓶颈值 3.更新残量图 4.添加反向路径 重复以上过程
​									缺点：时间消耗上限太高
​	优化**Edmoud’s-karp算法**：1.最短路径（无权最短路径）BFS O(m2*n)2.瓶颈值 3.更新残量图 4.添加反向路径 重复以上过程
​	                     **Dinic’s算法**：1.残量图 ->层序图 2.为层序图求阻塞流 3.用求得的阻塞流流经残量图加反向路径 重复以上过程直到没有办法生成层序图      时间复杂度 O（n2*m)

------------



### 马拉车算法：求最长回文子串

​	通过巧妙的回文的对称性，避免了传统中心扩展法的重复计算
​		**1.预处理字符串：**在原字符串的每个字符前后插入一个特殊符号（如`#`），并在首尾各加一个不同的边界符号（如`^`和`$`）防止越界。 **目的：**统一处理奇数长度和偶数长度的回文子串，避免分类讨论。
​		**2.定义核心变量：**p[i]回文半径，表示以新字符串第 `i` 位为中心的最长回文子串的**半径长度**`C`：当前已知最长回文子串的**中心位置**。`R`：当前已知最长回文子串的**右边界位置**（`R = C + P[C]`）
​		**3. 遍历计算p[i]:**1.利用对称性优化初始值 2.中心扩展法更新p[i]  

- 若 i 在当前最长回文右边界内（i <R），利用对称点 i_mirror 的 P 值，初始化 P [i] 为 min (R-i, P [i_mirror])

- 以 i 为中心扩展回文，更新 P [i]

- 若扩展后右边界超过 R，更新中心 C 和右边界 R 为当前 i 和 i+P [i]

  **4.计算最长回文子串**

---

### a-β剪枝

​	**α（Alpha）**：Max 玩家当前能保证的**最大收益下限**，初始为`-∞`，仅在 Max 层更新（只增不减）
​	**β（Beta）**   ：Min 玩家当前能保证的**最小收益上限**，初始为`+∞`，仅在 Min 层更新（只减不增）
​	**剪枝触发条件**：当`α ≥ β`时，当前分支结果无法影响最终决策，直接停止遍历该分支。

**Max 层（Max 玩家决策）**：递归评估子节点，用子节点收益更新 α（取 max (α, 子节点值)），若`α ≥ β`则剪枝，最终返回 α；
**Min 层（Min 玩家决策）**：递归评估子节点，用子节点收益更新 β（取 min (β, 子节点值)），若`α ≥ β`则剪枝，最终返回 β；

---

 



​	


​	







#### 																	

