时间和空间复杂度

# 计算复杂度的要求

1. 多项式里只保留最大项（最高次幂）
2. 常数项系数舍去
3. 方法可以在有限可数的资源消耗内(与输入的数据量n无关)完成，是常量复杂度，记为O(1)



# 计算空间复杂度

1 如果消耗的空间不随着输入数据量的变化而变化,则空间复杂度为O(1) 如果变化,则为O(n)





# 线性数据结构



# 数组和链表的区别

数组 : 空间大小固定,内存空间连续,可以通过下标索引访问,所以访问速度快,但是插入和删除比较慢

链表 : 空间大小不固定会随着链表长度的增加而变化,内存空间不连续,只能通过顺序访问,所以访问速度慢,但是插入和删除比较快

二叉树非递归的中序遍历

# 如何找到一个有环链表的入口节点

1 设置两个变量A B一个走的快,一个走的慢,两者如果有交点,说明有环,环从该点断开,就变成了两个链表找相交的问题



2 设置两个变量A B一个走的快,一个走的慢,两者如果有交点,说明有环,然后跑一圈,求环的总长度,然后在起点设置两个变量,第一个变量先跑环的长度,然后两个一起跑,两者的相遇点就是所求点

# 如果合并两个有序链表

首先检测是否为空,如果为空则返回,如果不为空,则比较两个有序链表的表头,将其中较小的元素作为表头,然后将该元素的指针指向该链表的下一个元素,然后将比较两个指针指向的元素的大小,小的插入新的链表中,然后将小的元素的指针指向下一个元素,然后循环进行以上操作

# 如何用两个队列实现栈

如果进行插入操作,则将元素放入其中有元素的队列中,如果进行删除操作,假设在有元素的队列中有n个元素,则将n-1个元素

放入到另一个队列中,然后将剩余的一个元素弹出.然后重复进行上面操作

# 数组实现循环队列

两个指针,分别指向头和尾

# 如何求链表的倒数第k个结点

1. 暴力一遍,判断该链表有多少个点,假设有n个,则再遍历第二遍,第n-k+1就是所求的值

2. 指针1先移动k-1位，然后指针2在链表表头，一起往后移动，直至指针1的下一个为空

   

   # 如何实现单向链表的倒置

   栈

   头插法

   

   # 单向链表的折叠

   找到链表的中间点,将链表中间点后边的链表倒序,然后这样就出现了两个链表,然后循环交替指向,变为一个所求的链表

   # 如何判断一个单向链表是否回文链表

   - 链表中数据压栈，与原链表依次对比
   - 快慢指针确定中间节点，后半部分逆序后比较
   - 快慢指针确定中间结点，后半部分压栈后比较

# 括号匹配：

###### 栈

# 将n个链表合成一个有序链表

首先检测是否为空,如果为空则返回,如果不为空,则比较两个有序链表的表头,将其中较小的元素作为表头,然后将该元素的指针指向该链表的下一个元素,然后将比较两个指针指向的元素的大小,小的插入新的链表中,然后将小的元素的指针指向下一个元素,然后循环进行以上操作

将所有链表用以上操作两两合并

# 复杂链表的复制

先合并链表，使下一个元素的复杂指针指向的使当前元素复杂指针的下一个，然后分离链表 时间复杂度O(n)，空间复杂度O(1)

# 判断两个单向链表是否有交点

- 暴力:依次指向第一个链表的每一个节点,然后每指向一个节点就遍历第二个链表一次,看看是否是指向同一个节点
- 入栈: 将两个链表入栈,看栈顶元素是否相同,入果相同,那么说明就是相j交链表
- 数学: 算出两个链表的长度差值,将长的链表减去差值开始遍历,如果能相交,说明就是相交链表

# 如何用栈实现队列

开两个栈,命名为队列1 和队列2 当实现添加操作时,将元素放进栈1里面,当实现弹出操作时,将栈1里面的操作放进栈2里面,这样就实现了栈里面元素的倒置,然后将栈顶元素弹出,再将元素放入栈1里面,这样就实现了栈的弹出操作

# 约瑟夫环

用队列模拟这个过程,创建一个标记位,每从队列里面取出一个元素,就将标记位➕1,如果当前标记位达到K的时候说明该元素要删除,则直接弹出,然后将标记为归0,否将元素再次放入队列中





# 哈希

# 哈希冲突解决方案

1 开放地址法

​	线性探测

​		发生冲突时，通过在哈希表中依次探查下一个槽位，位置为空则放入元素

​	二次探测

​		沿当前冲突位置，往后移动递增数的平方，判断当前位置是否存在元素

2 拉链法

​		当多个元素到同于个槽位时,则将该位置作为一个链表的表头,对于同一位置的元素,依次存储在改链表中

# 开放寻址法和拉链法的优缺点

#### 拉链法的优点

- **处理冲突简单**：拉链法通过创建链表来解决冲突，使得处理冲突变得相对简单 
- **无堆积现象**：在拉链法中，即使发生冲突，也不会导致数据堆积在一起，因此可以保持较好的查找性能 
- **删除操作简便**：在拉链法中，删除节点相对简单，只需要调整相应链表的指针即可

#### 拉链法的缺点

- **额外空间需求**：拉链法需要额外的空间来存储链表的指针，这在节点规模较小时可能不如开放寻址法节省空间 

#### 开放寻址法的优点

- **空间利用高效**：开放寻址法不需要额外的空间来存储链表的指针，因此在节点规模较小时，它可能比拉链法更节省空间 

#### 开放寻址法的缺点

- **冲突代价高**：一旦发生冲突，开放寻址法可能需要线性时间来探测下一个空闲位置，这在高负载情况下可能导致性能下降 
- **删除操作困难**：开放寻址法在删除节点时需要特别处理，通常需要设置一个标记来表示节点已经被删除，而不是真正从数组中移除节点

# 哈希表如何创建

散列表（HashTable），也叫哈希表，是根据键（key）而直接访问在内存中存储位置的数据结构，也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度，这个映射函数称为散列函数，存放记录的数据叫做散列表

# 哈希表增删查时间消耗

如果不发生冲突就是O(1),否则就是O(n);





# 字符串

# 字符串右移k位：

整体反转+局部反转

# 求一个字符串的全排列



# 如何在一个字符串中查找另外一个字符串首次出现的地址

KMP 

首先求一个匹配数组,从头第二个开始遍历,如果头和尾相同,匹配数组对应位置标记为1,然后依次往下遍历,在原来的基础上,如果相同,那么匹配数组加1 否则将当前尾的位置替换成与之对比的位置,然后继续比较



# 实现字符串反转

先整体反转再局部反转



# 找到字符串内第一个只出现一次的字符：

哈希

暴力遍历

# char *str1="hello" 存储在常量区

- sizeof(strl):strl表示字符指针，大小为4
- strl="Haha":strl可以改变指向，是常量指针
- "strl="ss”:常量区不可通过指针修改字符串内容
- sizeof(*strl)=1，表示数组首地址所代表的字符

# char str2[]="Hello"储存在堆区

- sizeof(str2)=6,表示数组大小，注意隐藏的‘/0’
- str2="Hello"不可操作，str2是指针常量无法改变指向
- *str2='h'可修改因为其在栈区分配空间

​		sizeof(str2)=1，表示数组首地址所代表的字符



# sunday算法

 首先将匹配串与原串匹配等长的长度如果相等直接返回,否则,找到原串与匹配串匹配位置的下一个位置,然后找到匹配串从右往左第一个出现的与该位置相同的字母,依次进行上面步骤,至于找字母,用哈希存储一下位置就可以了



# 二叉树



# 二叉树的性质

k层二叉树的总节点个数最多为2^K-1

总叶子个数最多2^(k-1)

对任何一棵二叉树, 如果度为0其叶结点个数为n0 , 度为2的分支结点个数为n2 ,则有 n0＝ n2＋1

# 完全二叉树的性质

- 将一棵完全二叉树按照从上到下，从左至右的顺序从1开始编号(1'n) 编号为i的节点，如果满足 2*i<=n．则有左孩子，编号为2*i 2*i+1<=n，则有右孩子，编号为2*i+1 父亲编号范围为1‘n/2

  

- 若规定根节点的层数为1，具有n个结点的满二叉树的深度，h= log2N下取整+1



# 二叉树的层序遍历

记录当前层节点个数 :开两个标记,记录一下当前层节点个数,然后随着节点的变化而进行加减

标记航末节点:

双队列保存父子节点

补空

# 二叉树的右视图

记录当前层节点个数 :开两个标记,记录一下当前层节点个数,然后随着节点的变化而进行加减

标记航末节点:

双队列保存父子节点





# 判断一个数组是否是排序二叉树的后序遍历

1.确定根节点:首先，我们需要确定数组的最后一个元素是二叉树的根节点。
2.寻找左子树和右子树:然后，遍历数组(不包括根节点)，找到第一个大于根节点的位置，那么这个位置左侧的所有元素都属于左子树，右侧的所有元素都属于右子树。
3.检查子树:接下来，我们需要检查左子树和右子树是否也是二叉搜索树。对于左子树，我们需要确保所有的元素都小于根节点;对于右子树，我们需要确保所有的元素都大于根节点
4.重复上述过程:对于左子树和右子树我们还需要重复上述过程，以确保它们也都是二叉搜索树的后序遍历。



# 如何将一个bst变成一个有序的双向链表

进行中序遍历,双向储存

# 排序二叉树的删除

二叉搜索树的删除,如果当前删除节点有0个孩子,则直接删除该节点,如果当前节点有一个孩子,则直接删除该节点,然后判断该节点的孩子是否有孩子,如果有,将当前节点的与他孩子的孩子相连,如果有两个孩子,则找到当前节点孩子中左子树最大或者右子树最小,然后将删除节点替换成当前节点孩子中左子树最大或者右子树最小,然后判断当当前节点孩子中左子树最大或者右子树最小是否有孩子,如果有,则将他的孩子与他的父亲相连

# 中序后序求二叉树前序遍历

通过后续遍历的特点找到根节点,然后在中序遍历中找到根,左边是左子树,右边是右子树,然后通过左子树和右子树的元素去遍历后序遍历,找到左子树和右子树在后序遍历中最后一个出现的元素,这两个点就是根左做儿子和右儿子,然后重复进行上面操作



# 在一棵BST里如何寻找和为n的整数对

首先确定一个BST树里的某个值,然后计算n和该值的差,然后在BST里搜索该值



# 排序二叉树的创建

如果树为空, 则新节点为根

如果不为空,则判断该值与根节点的大小关系,如果大,在右子树,否则在左子树,然后循环进行该操作,直到找到的位置为空

# 二叉树的右旋

假定父亲节点为A左儿子为B,右儿子为C

先看儿子的变化

那么右旋就是将B的右儿子变为A,B的右儿子变为C的左儿子,然后看看A是否有父亲,如果有则将A的父亲的儿子变为B,如果没有则将B变为根

再看父亲的变化

如果A的左侧不为空,则将A的左儿子的父亲变为A,A的父亲是B,B的父亲是A的父亲

# 在有n个结点的二叉树进行搜索的时间消耗

O(nlogn)

# 二叉树的非递归三序遍历

前序

根左右顺序,利用栈来实现非递归,首先打印当前元素,然后将当前元素放进栈中,然后判断当前元素是否有左儿子,如果有,则将左儿子作为当前元素继续进行以上步骤直到没有左儿子位置,然后判断栈是否为空,如果为空则表明完成了操作,直接退出,然后将栈顶元素取出,判断是否有右儿子,如果有则另当前元素等于栈顶元素的右儿子,继续继续进行以上判断

中序

左右根顺序,利用栈来实现非递归,首先将当前元素放进栈中,然后判断当前元素是否有左儿子,如果有,则将左儿子作为当前元素继续进行以上步骤直到没有左儿子位置,然后判断栈是否为空,如果为空则表明完成了操作,直接退出,然后将栈顶元素取出,打印栈顶元素,然后判断是否有右儿子,如果有则另当前元素等于栈顶元素的右儿子,继续继续进行以上判断

后序

左右根顺序,然后利用栈来实现非递归,首先将当前元素放进栈中,然后判断当前元素是否有左儿子,如果有,则将左儿子作为当前元素继续进行以上步骤直到没有左儿子位置,然后判断栈是否为空,如果为空则表明完成了操作,直接退出,然后将栈顶元素取出,如果他的右儿子等于空或者当前元素已经进行了是否有右儿子的判断(即创建一个标志位,当前标识为存储的是栈顶元素),则打印该元素,然后将该元素弹出,如果有右儿子并且标志位不等于栈顶元素,那么则另当前元素等于栈顶元素的右儿子,然后继续进行以上判断,直到栈为空为止



# 什么是平衡二叉树

​	定义:左右子树的深度差值小于1的BST

# 哈希表和红黑树

哈希表: 空间固定，数据量少

红黑树: 频繁增删，数量不确定，可用于在内存中使用

# 红黑树的性质

紅黑树：RBT 1.每个节点不是紅的就是黑的 2. 根节点必须是黑色的 3.每条路径末尾的空被称之为终端节点，被认为是黑色的，也被叫做黑哨兵 4. 不允许两个红节点是父子关系 5.从任意节点向下出发，到其所能到达的各个终端节点的各条路径上黑节点的数目必须是完全相同的

# 红黑树的衍生特质

红黑树上不会有一条路径长度超过其他路径长度的二倍 

红黑树的增删查时间复杂度是log2n

# 红黑树的增加

(1)如果树为空,则直接将新节点变为黑色,作为根节点 

(2)如果插入节点的父亲为黑色,则直接插入 

(3)如果插入节点的父亲为红色,则看该节点的叔叔,如果该节点的叔叔为红色,那么将该节点的父亲和叔叔变为黑色,然后将该节点的爷爷变为红色,以该节点为新节点,重复以上操作,如果叔叔为黑色或者没有,则看该节点的父亲是该节点的爷爷左还是右,如果父亲是爷爷的左,看自己是父亲的左还是右,如果是自己是父亲的右,则以父亲为新节点,以该点为为旋转点左旋,如果自己是父亲的左,则父亲变黑,爷爷变红 以爷爷为旋转点右旋,如果父亲为爷爷的右,则与之相反

# 红黑树的删除

- 1、查找出要删除的元素
- 2、如果有两个孩子，那么用左子树的最右或右子树的最左将其进行值覆盖
- 3、颜色
  - 如果z为根，且没有孩子，则删z，赋空
  - 如果z为根，且有一个孩子，则孩子为新根，孩子成为root
  - 如果z为红色叶子结点，则删z
- 4、z为黑色且不是根结点，z有一个儿子，则删除z，使红子变黑，爷孙相连
- 5、z为黑色，非根且无子
  - 1、兄弟为红色 父亲变红色，兄弟变黑色 以父亲为旋转点旋转
  - 2、兄弟是黑色
    - 1、若左侄子红色，右侄子黑色
      - 若兄弟在父亲的右
      - 若兄弟在父亲的左
    - 2、若右侄子红色
      - 若兄弟在父亲的左
      - 若兄弟在父亲的右

# 红黑树增删查时间复杂度

O(logn)



# 红黑树的增加和删除最多几次旋转后结束

插入: 2

删除: 3





# B树，

B树.

M阶B树就是M叉 

2.节点内记录个数<=m-1

 3.根节点内的记录个数>=1 

4.其他节点内的记录个数>=ceil(m/2)-1

 5.每个节点内的记录的索引值从左到右从小到大有序 

6.每个记录的左子树的值均小于当前记录，右子树的值均大于当前记录

# B树的添加

添加: 1.空树，新来记录放入节点中，当前节点既是根也是叶子 

2.非空树，将新记录添加到叶子节点中;

 3.检测节点内记录个数 (1)<=m-1，结束 (2)>m-1，裂变:中间记录上移至父亲层，左侧记录成为其左子树，右侧记录成为其右子树，对父亲节点重复3

# B树的删除

 1.被删除记录位于非叶子节点，找到左子树最大或右子树最小侧记录进行替换，删除叶子节点内的对应记录

 2.讨论节点内记录个数 （1) >=ceil(m/2)-1，结束 2） sceil(m/2)-1，看兄弟节点内的记录个数 1J>ceil(m/2)-1，父亲记录下移至当前节点，兄弟节点上移一个记录之父亲节点，结束 [2J=ceil(m/2)-1，父亲记录下移，与当前节点和兄弟节点合并成一个新节点，讨论父亲节点记录个数，同2

# B+树的定义

B+树

1.M阶B+树，M叉 

2.B+树节点分为内部节点(索引节点)和叶子节点 

3.每个节点内的记录或索引个数<=m-1 

4.根节点既可以是叶子节点也可以是索引节点 

5.根节点内的记录或索引个数>=1 

6.其他节点内的记录或索引个数>=ceil(m/2)-1 

7.每个节点内的记录或索引从左至右从小到大有序 

8.每个索引的左子树的值均小于当前索引，右子树的值均大于当前索引 

9.相邻的叶子节点间有指针从左至右指向



# B+树的添加

1.将新记录添加到叶子节点 

2.讨论叶子节点内的记录个数 (1)<=m-1，结束 (2)>m-1，裂变:前m/2个记录成为左子树，剩余记录成为右子树，第m/2+1个记录的索引复制一份至父亲节点，讨论父亲节点索引个数: [1]<=m-1，结束 [2]>m-1，裂变:中间索引上移至父亲节点，左侧索引成为其左子树，右侧索引成为其右子树，讨论父亲节点索引个数同[1][2]

# B+树的删除

 1.查找，找到叶子节点，进行记录删除

 2.讨论叶子节点记录个数 (1)>=ceil(m/2)-1，结束 (2)<ceil(m/2)-1，看兄弟节点记录个数 [1]>ceil(m/2)-1，兄弟节点移动一个记录至当前节点，更父亲节点的索引，结束[2]=ceil(m/2)-1，当前节点与兄弟节点合并成一个新节点删除父亲索引，讨论父亲节点索引个数 a:>=ceil(m/2)-1，结束 b:<ceil(m/2)-1，看兄弟节点的索引个数: I:>ceil(m/2)-1，父亲索引下移至当前节点，兄弟节点上移个索引至父亲节点，结束II:=ceil(m/2)-1，父亲索引下移，与当前节点和兄弟节点台并成一个新节点，讨论父亲节点索引个数，同a,b



# b和b+区别范围搜索

- 在搜索上，B树离根节点越近，搜索时间越短，B+树搜索时间为固定的logmn，B+树进行范围搜索极其方便，可以从叶子结点从左往右搜索
- 数据库的数据在磁盘里，在内存里进行操作时，使用哈希表时内存一次性不能更改完。进行B树加载时只需加载某一个结点，根据当前结点的大小来重新加载下一个位置的结点，更节省内存



# 哈夫曼编码如何实现

1.将所有带权节点按照权值大小排序

2.取前两个最小的拿走，构成新节点

3.新节点放回序列，重新排序，重复以上步骤直到剩下一个为止



# 一个有4n个叶子结点和2n个叶子节点的哈夫曼树，总结点分别是多少

8n-1

4n-1



# 博弈术的特点

- 特点：全信息，非偶然，零和



# 如何找二叉树中和为某一个值的路径：

要找二叉树中和为某一个值的路径，可以使用深度优先搜索（DFS）算法。具体步骤如下：
从根节点开始递归遍历二叉树，同时记录当前路径上的节点和路径值。
在递归过程中，每到达一个节点，将当前节点加入路径，并更新路径值。
如果当前节点是叶子节点（即没有左右子节点），并且路径值等于目标值，则将当前路径加入结果集合中。
如果当前节点不是叶子节点，则分别递归遍历它的左子树和右子树。
在递归返回前，将当前节点从路径中移除，以回溯到上一层节点。



















# 图

# 图的概念

- 无向图
  - 图中的边无次序关系和方向性
- 有向图
  - 图中的边有次序关系和方向性
- 无向完全图
  - 图中所有定点之间所有可能的边都可能存在,所以最多有n*(n-1)/2边
- 有向完全图
  - 图中所有定点之间所有可能的边都可能存在,所以最多有n*(n-1)条边
- 连通图
  - 所有点之间都能相互到达
- 有向连通图
  - 图中所有相异的顶点都是连通的
- 路径
  - 简单路径
    - 除起点和终点可能相同以外，其他顶点不能重复出现
- 极大连通子图（连通分量）
  - 连通图的连通分量是本身
- 度
  - 有几条边指向他,他指向别人几条边

# 邻接矩阵和邻接表的区别：

1. 邻接矩阵
   - 在边多的时候使用
   - 邻接矩阵唯一
2. 邻接表
   - 在边少的时候使用
   - 邻接表不唯一

# 图的深度优先遍历

设置起始点并打印，找到当前顶点的邻接点，若邻接点没有处理过，先打印，后找邻接点的邻接点，直到当前点的所有邻接点都处理过，则回退到上一个顶点

# 图的广度优先遍历

设置起始点并入队，先将队首弹出打印，再将所有未打印的邻接点依次入队，对其进行标记，重复以上过程，直到所有顶点处理完成

# 找到图中一个点到其中各个点的最短距离

dijkstra

1.初始化:将起点到每个节点的距离设为无穷大，将起点到自己的距离设为0
2.选择起点:选择起点并标记为已访问。
3.扩展节点:遍历所有与起点相邻的节点，计算经过起点到达这些节点的距
离，并更新距离
4.选择下一个节点:从未访问过的节点中选择距离起点最近的节点，并标记为已访问。
5.重复步骤3和4，直到到达终点或所有节点都被访问。





# 最小生成树

- 克鲁斯卡尔
  - 寻找全图中最小的边
- 普利姆
  - 寻找所有顶点的边中最小的一个





# 一个有n个顶点的无向图，最少有多少条边才能连通

- n-1

# 一个有n个顶点的无向图，最少有多少条边才一定是连通图

- (n - 1)(n - 2) / 2 + 1







# 拓扑排序的实现

- 1. 计算每个顶点的入度，入度为0表示学习该课程之前无需学习其他课程，可以直接学习此课程
- 2.队列，将入度为0的顶点入队
- 3.对队列中的顶点进行处理： (1)弹出队头顶点 (2)邻接点入度更新 (3)将新的入度为0的顶点入队，重复3，直到队列为空

- - 





# 有n个顶点的有向完全图，边最多有多少条

n*(n-1)



# 什么样的图是连通图

任意两顶点间都有路径相通



# 分治和递归

# 什么样的问题用分治法

1、问题难度随着数据规模的缩小而降低 

2、问题可拆分

 3、子问题的解可合并 

4、子问题的解之间相互独立

# 递归适用于什么问题

1.必须可以分解为若干个规模较小，但是与原问题形式相同的子问题。并且这些子问题可以用完全相同的解决思路来解决

 2.递归问题的演化过程是一个原问题从大到小进行拆解的过程，并且会有一个明确的终点最后从这个临界点开始，把小问题的答案按照原路返回，原问题便得以解决。



# 数组前半部分单调递减，后半部分单调递增，找最小值

二分,首先找到中间值,将中间值和前一个位置比较,如果比前面大,说明是递增部分,将区间该为从头到该位置,如果比前面小,则在递减部分,将区间该为该位置到末尾,循环往复



# 排序

# 数组中有两个元素只出现一次，其他元素出现两次，找出这两个元素

1 哈希

2 排序 

# 排序算法总结



# ![截屏2024-03-07 17.59.00](/Users/a0.97/Library/Application Support/typora-user-images/截屏2024-03-07 17.59.00.png)



# 冒泡排序

如果相邻元素大小满足条件，则将相邻元素交换，使最后一个元素为最大元素



# 选择排序

选择一个最值，使其位置变为数组前端或末端

# 插入排序

适合元素很少(n<16)的情况 每个元素排序前的位置距其排好序的最终位置不远的时候

如果当前元素小于前面的元素,将当前元素与前面的元素替换,直到当前元素大于前一个元素停止,然后依次类推

# 希尔排序

将数据进行分组，各组内插入排序，最终进行整体插入排序

# 计数排序

优化版: 保证相同元素的相对位置大小不改变 首先找到数组的最大值和最小值,计算一下差值,然后开一个差值大小的标记数组,计算每一个数出现的次数,然后将标记数组求一下前缀和,开始从后向前遍历原数组,找到数所对应的标记数组的位置,将元素放到该位置,然后将标记数组的对应值减1

# 快速排序

首先确定一个标准值(一般为第一个数),然后有两个指针,一个指向标准值,另一个指向末尾,然后将标准值取出保存,从后向前找比标准值小的,找到后与标准值替换位置,然后找该位置前面比标准值大的,进行替换,依次类推(也就是说指针分别指向两个位置,一个是标准值,一个是前一次替换的位置,通过指针位置确定向前找还是向后找)分割之后循环进行以上步骤



区间分割法,首先定义两个标记,第一个标记指向第一个数的前一个位置,第二个标记指向第一个第一个数的位置,假定标准值为最后一个数,那么开始操作,如果第二个标记的位置对应的数比标准值小,则将该位置的数放在第一个标记位置的后一个位置,然后第一个标记向后移动一个,然后第二个标记值向后移动一个位置,继续进行上述操作,直到将整个区间分成以标准值区为分点的两个区间,然后对两个区间继续进行以上操作,直到所有区间都完成操作



# 归并排序

首先分割,把一个数组分割成多个两个区间,然后这两个区间都在分割成两个区间,依次类推,知道不能分割,然后对这些小区间进行排序,最后在把区间合并,时间复杂度为O(nlogn)

# 基数排序

1.找max 2.计算max位数 3.按位处理：低->高    创建组    拆位    分组(尾) 4.放回 5.释放



# 堆排序

- 堆排序原理
  - 1.建初始堆
    - 从最后一个父亲节点依次向前调整
  - 2.排序
    - 元素交换（大根堆父亲为大元素，小根堆父亲为小元素）
    - 调整堆顶
  - 如何调整
    - 1
      - 以大根堆为例 首先找到孩子中的较大值
      - 使较大值与父亲比较
        - 若较大值 < 父亲 ，结束
        - 若较大值 > 父亲，交换 从较大值原位置处继续调整
    - 2
      - 建立标记为父亲下标，若孩子大于父亲则更新标记值，最后判断标记与父亲下标是否相同，若相同则结束，若不相同先交换，后调整



# 其他问题

# 如何不用加减乘除实现加法运算

![截屏2024-03-07 15.46.11](/Users/a0.97/Library/Application Support/typora-user-images/截屏2024-03-07 15.46.11.png)





![image-20240307160055818](/Users/a0.97/Library/Application Support/typora-user-images/image-20240307160055818.png)

# 



# 判断一个数是否是2的幂

1. 递归法，不断除以二
2. 位运算法，只有一个1

# 快速幂

long long fastPower(long long base, long long power) {
    long long result = 1;
    while (power > 0) {
        if (power & 1) {//此处等价于if(power%2==1)
            result = result * base % 1000;
        }
        power >>= 1;//此处等价于power=power/2
        base = (base * base) % 1000;
    }
    return result;
}



# 最长上升子序列

首先对于最长上升子序列问题,我们要求n个数的最长上升子序列，可以求前n-1个数的最长上升子序列，再跟第n个数进行判断。求前n个数的最长上升子序列,所以可以用dp[i]表示以第i个数结尾的最长上升子序列,那么根据双层for循环就可以列出状态转移方程 dp[i]=max(dp[i],dp[j]+1)



# 还有动态规划，小人直往右或者只往下，到终点



```
dp[i][j]=dp[i][j]+max(dp[i][j-1],dp[i-1][j])
```



# 给你一个数组，前半部分递减后半部分递增，让你快速找到min

二分





# 给你一个无序数组，找到里面的最大连续子数组

```
#include<iostream>
using namespace std;
int n,a[200020],b[200020],i,ans=-2147483647;
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
        if(i<2) b[i]=a[i];
        else b[i]=max(a[i],b[i-1]+a[i]);
        ans=max(ans,b[i]);
    }
    cout<<ans;
    return 0;
}
```



# 二叉树高度计算

dfs



# 快排优化
