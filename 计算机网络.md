## 三阶段网络复习

## 网络

##### 协议 protocol:双方规定好的，数据在网络传输中需要遵守协议

#### 七层网络模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

<img src="C:\Users\zhanr\AppData\Roaming\Typora\typora-user-images\image-20251115101945296.png" alt="image-20251115101945296" style="zoom:50%;" />

##### 应用层

提供应用程序进行数据传输
**HTTP/HTTPS协议：**浏览器使用的协议 	HTTPS中的S是SSL加密，更安全
**FTP协议：**文件传输协议  
**DNS协议:**域名解析协议  域名：俗称网址  
**DHCP协议：**动态获取网络配置  自动分配IP

##### 表示层

数据加解密	数据解压缩	图片/视频编解码

##### 会话层

session会话管理	服务器验证用户登录	断点续传
session会话管理：Session 是服务器通过 Session ID（通常存于客户端 Cookie）关联用户跨请求状态、解决 HTTP 无状态问题的会话管理机制。 	例：跳转网页时不需要重新登录

##### 传输层

操作系统提供的，用户需要告诉操作系统用哪一个
TCP	UDP	线程	端口	socket
**端口号：**一个端口号只能被一个应用程序绑定 一个应用程序能绑定多个端口号。	IP决定数据到达设备 端口号决定数据到达应用程序
**socket:**套接字，是通信的基石，是支持TCP/IP协议的网络通信包含进行网络通信必须的五种信息：
				连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口

**TCP:**面向连接，可靠的，基于字节流的	需要数据稳定性和可靠性比较高的场景
**UDP：**无连接的，高效率，低可靠性的数据传输服务	需要数据时效性比较高的场景多使用UDP协议

##### 网络层

ARP	RARP	IP  防火墙	路由器(通过网络地址)

##### 数据链路层

网卡  MAC地址(物理地址)	交换机(通过物理地址)

##### 物理层

把数字信号转换成电信号和光信号	网线和光缆
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251115112305747.png" alt="image-20251115112305747" style="zoom:33%;" />

#### C/S 架构对比 B/S

C/S:客户端 服务器		1.每一个应用程序有自己独立专门的客户端	2.客户端，服务端可以使用任意的网络传输协议
B/S:浏览器 服务器		1.客户端不固定，使用任何一款浏览器			2.协议固定	http/https

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251115134709972.png" alt="image-20251115134709972" style="zoom:33%;" />

**加载库	创建套接字	绑定IP和端口号	接消息：recvfrom()	回消息：sendto()	关闭套接字	卸载库**
绑定IP和端口号：为了让操作系统知道当前进程使用的是哪个ip和端口
服务端先接收消息 

**静态库**：编译链接时，库代码直接拷贝到程序中，运行时不依赖外部文件，体积大、更新需重编译，独立可运行。在可执行文件中
**动态库**：编译链接仅记录依赖，运行时由系统加载到内存共享，体积小更新无需重编程序，依赖库文件存在才能运行。不在可执行文件中

静态库的优点：移动或分享时只移动可执行文件即可
动态库的缺点：移动和分享的时候不仅需要提供可执行文件还需要提供dll	执行效率会比静态库慢一些
动态库的优点：如果库里代码进行修改不需要重新编译可执行文件，用户重新下载新的动态库的包就行
						 多个可执行文件依赖一个动态库的时候，只需要内存中拷贝一份动态库

使用静态库的步骤：1.包含头文件	2.导入依赖库 #pragma comment
使用动态库的步骤：1.包含头文件	2.导入依赖库 (链接库.lib)#pragma comment	3.dll拷贝到exe相同路径下

#### UDP Server

`sockaddr` 是通用地址接口，`sockaddr_in` 是 IPv4 专用地址结构，强转是为了： 1. 统一 socket 函数（bind/connect 等）的参数类型； 2. 兼容 IPv4/IPv6 等多种地址类型，靠结构中地址族字段区分解析。

```cpp
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include<iostream>
using namespace std;
#include<WinSock2.h>
//导入依赖库
#pragma comment(lib,"Ws2_32.lib")
int main() {
	//1.加载库
	WORD version = MAKEWORD(2,2);
	WSADATA data = {};
	int err=WSAStartup(version, &data);
	if (err != 0) {
		cout << "WSAStartup error" << endl;
		return 1;
	}
		//判断加载成功的库的版本号是否正确（因为加载上来的版本号可能不是2，2）
	if (HIBYTE(data.wVersion)==2&&LOBYTE(data.wVersion)==2) {
		cout << "WSAStartup success" << endl;
	}
	else {
		cout << "WSAStartup version error" << endl;
		return 1;
	}
	//2.创建套接字
	SOCKET sock= socket(AF_INET/*address family IPV4*/,SOCK_DGRAM/*socket类型 UDP*/,IPPROTO_UDP/*协议类型*/);
	if (INVALID_SOCKET==sock) {
		cout << "socket fail:" <<WSAGetLastError<< endl;
		//卸载库
		WSACleanup();
		return 1;
	}
	else {
		cout << "socket success" << endl;
	}
	//3.绑定ip和端口
	sockaddr_in addr;
	addr.sin_family = AF_INET;	//ip地址类型
	addr.sin_port = htons(34567);		//大端小端,网络字节序（大端），PC是小端存储，需要转换成网络字节序
	addr.sin_addr.S_un.S_addr = INADDR_ANY;	//绑定所有网卡
	err = bind(sock,(sockaddr*) & addr,sizeof(addr));
	if (SOCKET_ERROR==err) {
		cout << "bind fail:" << WSAGetLastError << endl;
		//关闭套接字
		closesocket(sock);
		//卸载库
		WSACleanup();
		return 1;
	}
	else {
		cout << "bind success" << endl;
	}
	while (true) {
		char recvBuf[4096] = "";
		char sendBuf[4096] = "";
		//对端的地址信息
		sockaddr_in addrClient = {};	//输出参数不用赋初值
		int size = sizeof(addrClient);
		int nRecvNum = 0;
		int nSendNum = 0;
		while (true) {
			//4.接收数据
			nRecvNum=recvfrom(sock, recvBuf, sizeof(recvBuf), 0, (sockaddr*)&addrClient, &size);
			if (nRecvNum > 0) {
				//接收成功，打印接收到的数据和对端的ip
				cout << inet_ntoa(addrClient.sin_addr)<< ":" <<recvBuf<< endl;
			}
			else {
				cout << "recvfrom error" << endl;
				break;
			}
			//5.发送数据
			cin >> sendBuf;
			nSendNum=sendto(sock,sendBuf,sizeof(sendBuf),0, (sockaddr*)&addrClient,size);
			if (SOCKET_ERROR == nSendNum) {
				cout << "sendto error:" << WSAGetLastError() << endl;
				break;
			}
		}
	}
	//6.关闭套接字
	closesocket(sock);
	//7.卸载库
	WSACleanup();
	return 0;
}
```

```cpp
//ip两类：1.十进制四等分字符串类型；2.ulong类型
//	inet_ntoa():从ulong类型转到字符串类型--显示的时候一般使用字符串类型
//	inet_addr():从字符串类型转换到ulong类型--赋值使用
```

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251118195333147.png" alt="image-20251118195333147" style="zoom: 33%;" />

#### 数据包在传输过程中的变化

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251118195740280.png" alt="image-20251118195740280" style="zoom:33%;" />

#### 单播组播和广播

单播：一个设备发给一个设备
广播：一个设备发，很多个设备收，关注的是范围
组播：一个设备发，很多个设备收，关注的是设备 
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251118200904858.png" alt="image-20251118200904858" style="zoom:33%;" />

#### ARP协议

地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议（TCPIP协议族）<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251118201319257.png" alt="image-20251118201319257" style="zoom:33%;" />

  **触发 ARP 请求** 	**发送广播请求** 	**目标设备响应**	 **更新缓存并通信**

##### ARP代理

​	当发送端广播ARP请求时，本地网络上不会有主机回应（因为IP地址是外网的），此时路由器将会回应该请求，则发送源误认为路由器就是目的主机，会将报文全部转发给它，再由路由器转发报文到外网，则该路由器就被称为ARP代理

##### 免费ARP

​	在主机开机配置时，会发送一个目的IP地址为自己IP地址的ARP请求报文，该报文成为免费ARP
作用：1.让主机确认本地网络上是否有与自己IP地址相同的主机，若有则返回一个错误报文
​		   2.告诉整个广播域，目前某个IP所对应的MAC地址是什么  更新局域网 ARP 缓存
缓存：因为空间有限	老化机制:长时间不使用的数据就删掉，给新的数据腾空间

#### DNS协议

域名解析，DNS服务器将好记的域名解析成IP地址
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251118205214110.png" alt="image-20251118205214110" style="zoom: 33%;" />

#### 路由数据转发过程

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251118205644412.png" alt="image-20251118205644412" style="zoom:50%;" />

#### IP地址分类

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119111349773.png" alt="image-20251119111349773" style="zoom:50%;" />

#### 子网掩码

又叫网络掩码，地址掩码，子网络遮罩，就是说把子网络遮起来了，不让外界窥探到。
IP地址与子网掩码按位与
某主机的网络地址（对外的IP地址）  主机号被隐藏
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119112715545.png" alt="image-20251119112715545" style="zoom:50%;" />

##### 非默认子网掩码

在默认子网掩码上多加了几个1

#### 网关

又称网间连接器，协议转换器。网间连接器，就是连接两个子网之间的设备或软件
<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119112957173.png" alt="image-20251119112957173" style="zoom:50%;" />

#### 广播地址

用于向网络中的所有设备进行广播。具有正常的网络号部分，而主机号部分全为1的IP地址称之为广播地址
发送直接广播地址数据，会将数据发送给改子网内所有主机。

##### 有限广播地址

指的是32位全位1（255.255.255.255）的IP地址，用于本网广播。

#### 子网划分

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119114941737.png" alt="image-20251119114941737" style="zoom:50%;" />

##### 子网划分练习题

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119120012932.png" alt="image-20251119120012932" style="zoom: 33%;" />

一. 	210.33.5.0
二.	255.224.0.0 → 二进制（第二段）：`11100000`   x=3  子网个数:2^3=8;（每个子网包含主机数需-2）	
		步长：256-224=32；20.32.0.0	20.64.0.0	20.96.0.0 …….. 共8个
三.	<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119121115847.png" alt="image-20251119121115847" style="zoom:33%;" />

四.	<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119121656618.png" alt="image-20251119121656618" style="zoom:33%;" />

​	步长：256-248=8
​				<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119122048758.png" alt="image-20251119122048758" style="zoom: 33%;" /><img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251119122243506.png" alt="image-20251119122243506" style="zoom: 33%;" />



#### 代码

```cpp
客户端中

//直接广播：把发送地址的ip改为直接广播地址
serverAddr.sin_addr.S_un.S_addr = inet_addr("10.58.229.255");

//有限广播：需要先申请权限再发广播
BOOL val = true;
setsockopt(sock,SOL_SOCKET,SO_BROADCAST,(char*)&val,sizeof(val));
serverAddr.sin_addr.S_un.S_addr = inet_addr("255.255.255.255");
```

#### 阻塞和非阻塞

阻塞：老王烧水，把水壶放在炉子上，在旁边看着直到水开——事情发生的时候第一时间知道，等待的时候进程是挂起的不占用CPU
非阻塞： 老王烧水，把水壶放在炉子上，去看电视了，每隔一段时间回来看看水开没开

sock默认是阻塞的，接收和发送都是阻塞的
把socket设置成非阻塞的

```cpp
u_long iMode=1;
ioctlsocket(sock,FIONBIO,&iMode);
```

**发送的阻塞和非阻塞：**
	阻塞发送：发送缓冲区空间不足够大时，等待缓冲区空间足够大以后再发送
	非阻塞发送：当发送缓冲区空间不足够大时，有多大空间，就往里拷贝多少数据，剩余数据由进程自行处理（可以根据sendto返回值来判断）
	

####  缓冲区

exe可执行文件：不运行时：保存在磁盘里		运行时：调用到内存里   
虚拟内存：1.虚拟内存的核心是操作系统为进程提供的独立逻辑地址空间，屏蔽物理内存细节并实现进程隔离；
				  2.其具体实现是利用磁盘空间补充物理内存，通过页面换入换出扩展可用内存容量。
				  3.虚拟内存的地址并不是真正的地址，需要做一个运算映射到真实地址

内核空间是共用的，用户空间是自用的（代码中的 recvBuf sendBuf 进程自己的）

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251121133600151.png" alt="image-20251121133600151" style="zoom: 33%;" />

​	**缓冲区：**创建socket的时候，操作系统会在内核空间给每一个socket分配两个缓冲区（发送缓冲区，接收缓冲区）
​	**接收数据：**当数据到达操作系统，操作系统会根据目的端口号找到之前绑定的socket，把数据写入到socket对应的接收缓冲区
​	应用程序调用recvfrom函数时，就是从socket对应的接收缓冲区中拷贝数据到自己的空间
​	**发送数据:**进程调用sendto函数，把sendBuf中的数据拷贝到socket对应的发送缓冲区中，操作系统会把发送缓冲区中的数据发送出去

**查看发送缓冲区和接收缓冲区的大小：**getsockopt(sock,SOL_SOCKET, SO_RCVBUF,(char*)&recvSize,&s);

#### UDP协议特点总结

面向非连接，创建的socket可以接收任意人发来的数据，可以是一对一，也可以是一对多（广播，组播）
通讯方式：数据报文的通讯方式，数据不可拆分
传输效率高（跟TCP协议对比）
会产生丢包，也可能出现乱序，因为没有检查和校验，没有解决这些问题

#### 以太网帧结构

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251121144023680.png" alt="image-20251121144023680" style="zoom:50%;" />

MTU：一个网络包的最大长度，以太网中为1500字节
MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度

#### IP协议格式

<img src="C:/Users/zhanr/AppData/Roaming/Typora/typora-user-images/image-20251121144428497.png" alt="image-20251121144428497" style="zoom:50%;" />

### TCP





















































































































































































